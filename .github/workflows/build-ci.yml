# GitHub Action to CI build SocNetV for all 3 major OSes
# Triggered only when the commit message contains [gha] or [ci]

name: Build SocNetV (CI) üöÄ

on:
  push:
    branches:
      - develop

env:
  APP_NAME: "SocNetV"
  UNIXNAME: "socnetv"
  SOCNETV_VERSION: "3.2"      # TODO - READ FROM FILE
  VERSION: "3.2"              # WILL BE UPDATED DYNAMICALLY BELOW
  QMAKE_PROJECT: "socnetv.pro"
  PUBLISHER: "Dimitris Kalamaras"
  QT_MODULES: "qtwebsockets qtimageformats qt5compat qtcharts qtdatavis3d qtwebview qt3d"
  QMAKE_CONFIG: release  ## debug  # Never use debug. Windows builds will break.
  CMAKE_CONFIG: Release  ## Debug
  CORES: 16
  MAC_ARTIFACT: ""
  LINUX_ARTIFACT: ""
  APPDIR_PREFIX: "/usr"
  WINDOWS_ARTIFACT: ""
  UPLOAD_URL: ''


jobs:
  ci_build:
    permissions:
      contents: write  # Required to upload release assets
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-20.04, ubuntu-latest, macos-latest, windows-2019]
        # NOTE:
        # - We will CI build only for Qt6 LTS releases, see: https://doc.qt.io/qt-6/qt-releases.html
        # - For the Qt Versions supported by aqtinstall, see: https://ddalcino.github.io/aqt-list-server/
        qt-version: ['6.5.3', '6.8.0']
        # exclude:
        #   - os: ubuntu-latest
        #     qt-version: '6.6.3'
        #   - os: windows-2019
        #     qt-version: '6.6.3'
        #   - os: macos-latest
        #     qt-version: '6.6.3'
        # include:
        #   - os: macos-latest
        #     qt-version: '6.6.3'
        #   # Snapcraft
        #   - os: ubuntu-20.04
        #     qt-version: '6.5.3'
    runs-on: ${{ matrix.os }}
    if: contains(github.event.head_commit.message, '[ci]') || contains(github.event.head_commit.message, '[gha]')
    steps:
      - name: ü§ñ Job information, on branch ${{ github.ref }}
        run: |
          echo "üéâ The job was automatically triggered by a ${{ github.event_name }} event, by actor ${{ github.actor }}."
          echo "üêß This job is now running on a ${{ runner.os }} server hosted by GitHub!"
          echo "üîé The name of your branch is ${{ github.ref }} and your repository is ${{ github.repository }}."
      - name: üìÇ Check out repository ${{ github.repository }}
        uses: actions/checkout@v4
      - name: üí° List files cloned from the ${{ github.repository }}
        run: |
          ls ${{ github.workspace }}
          echo "üí° The ${{ github.repository }} repository has been cloned to the runner."
          echo "üñ•Ô∏è The workflow is now ready to test your code on the runner."
      - name: üí° Set version dynamically
        shell: bash
        id: set_version
        run: |
          # Check if this is a tagged commit
          if [ -n "${GITHUB_REF}" ] && [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/} # Extract tag name
          else
            LAST_COMMIT_SHORT=$(git rev-parse --short HEAD)
            VERSION="${SOCNETV_VERSION}-${LAST_COMMIT_SHORT}" # Use custom versioning for non-tagged commits
          fi

          # Export VERSION as an environment variable for subsequent steps
          echo "VERSION=${VERSION}" >> $GITHUB_ENV
      - name: Determined build version ${{ env.VERSION }}
        run: echo "VERSION is set to ${{ env.VERSION }}"
      - name: Check Rate Limit
        uses: actions/github-script@v6
        id: get_ratelimit
        with:
          script: |
            const { data: rateLimit } = await github.rest.rateLimit.get();
            console.log(rateLimit);
            core.setOutput("rate_limit", rateLimit);
          github-token: ${{ secrets.GITHUB_TOKEN }}
      - name: Use script to get continuous release Upload URL
        id: get_release
        uses: actions/github-script@v6
        with:
          script: |
            const { data: releases } = await github.rest.repos.listReleases({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            const release = releases.find(r => r.tag_name === "continuous");
            if (!release) {
              console.log("Continuous release not found. Exiting gracefully.");
              core.setOutput("upload_url", "");
            } else {
              core.setOutput("upload_url", release.upload_url);
            }
          result-encoding: string
          github-token: ${{ secrets.GITHUB_TOKEN }}
      - name: Fetch 'continuous' release upload URL
        shell: bash
        id: fetch_release
        run: |
          echo "steps.get_ratelimit.outputs.rate_limit = ${{ steps.get_ratelimit.outputs.rate_limit }}"
          echo "steps.get_release.outputs.upload_url = ${{ steps.get_release.outputs.upload_url }}"
          if [ -z "${{ steps.get_release.outputs.upload_url }}" ]; then
            echo "No continuous release found in get_release step."
          fi
          RELEASE_INFO=$(gh api -H "Accept: application/vnd.github+json" https://api.github.com/repos/${{ github.repository }}/releases/tags/continuous)
          UPLOAD_URL=$(echo "$RELEASE_INFO" | jq -r '.upload_url' | sed 's/{?name,label}//')
          echo "UPLOAD_URL=${UPLOAD_URL}" >> $GITHUB_ENV
          echo "UPLOAD_URL=${UPLOAD_URL}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: üóëÔ∏è Delete old assets from 'continuous' release (only once, from ubuntu)
        if: matrix.os == 'ubuntu-latest' && matrix.qt-version == '6.8.0'
        run: |
          echo "üîç Fetching existing assets from the 'continuous' release..."
          ASSETS=$(gh release view continuous --json assets -q '.assets[].name')

          if [[ -z "$ASSETS" ]]; then
            echo "‚úÖ No previous assets found in 'continuous' release."
          else
            echo "üóëÔ∏è Deleting old assets..."
            for ASSET in $ASSETS; do
              echo "‚ùå Removing $ASSET..."
              gh release delete-asset continuous "$ASSET" --yes
            done
            echo "‚úÖ Old assets deleted."
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      #
      # Install dependencies (build tools, cmake, etc)
      #

      - if: contains( matrix.os, 'windows')
        name: ü™ü Prepare for buiilding on ${{matrix.os}}
        run: |
          echo '‚öôÔ∏è Install dependencies for building....'
          # DONT NEED IT. FOR DEBUG ONLY
          # pip install aqtinstall
          # aqt list-qt windows desktop
          # aqt list-qt windows desktop --arch ${{ matrix.qt-version }}
          # aqt list-qt windows desktop --modules ${{ matrix.qt-version }} win64_mingw
      - if: contains( matrix.os, 'ubuntu')
        name: üêß Prepare for building on ${{matrix.os}}
        run: |
          echo '‚öôÔ∏è Install dependencies for building....'
          sudo apt install -y build-essential libssl-dev cmake ninja-build \
            libxkbcommon-x11-dev libxcb-cursor-dev zlib1g-dev libcups2-dev libvulkan-dev \
            desktop-file-utils patchelf libglu1-mesa-dev libfontconfig1 libfreetype6 libx11-dev libxext-dev \
            libxrandr-dev libxrender-dev libxcb1-dev libx11-xcb-dev libxcb-glx0-dev libfuse2
          # DONT NEED IT. FOR DEBUG ONLY
          # pip install aqtinstall
          # aqt list-qt linux desktop --long-modules ${{ matrix.qt-version }} win64_mingw
      - if: contains( matrix.os, 'macos')
        name: üçé Prepare for building on ${{matrix.os}}
        run: |
          echo '‚öôÔ∏è Install dependencies for building....'
          ls
          # DONT NEED IT. FOR DEBUG ONLY
          # pip install aqtinstall
          # aqt list-qt mac desktop --modules ${{ matrix.qt-version }}

      #
      # Install Qt (using https://github.com/jurplel/install-qt-action)
      #
      - if: contains( matrix.os, 'windows')
        name: Make sure MSVC is found
        uses: ilammy/msvc-dev-cmd@v1
      - if: contains( matrix.os, 'windows') && startsWith( matrix.qt-version, '6.' )
        name: Install Qt ${{ matrix.qt-version }} on ${{ matrix.os }}
        uses: jurplel/install-qt-action@v4
        with:
          aqtversion: '==3.1.*'               # Use the default aqtinstall version
          version: ${{ matrix.qt-version }}   # Qt version to install
          # arch: win64_mingw
          # NOTE: We build with default arch:
          #   win64_msvc2019_64 if Qt < 6.8
          #   win64_msvc2022_64 if Qt >= 6.8
          # see https://github.com/jurplel/install-qt-action
          modules: ${{env.QT_MODULES}}
          cache: true
      - if: contains( matrix.os, 'ubuntu') && startsWith( matrix.qt-version, '6.' )
        name: Install Qt 6 on ${{ matrix.os }}
        uses: jurplel/install-qt-action@v4
        with:
          aqtversion: '==3.1.*'               # Use the default aqtinstall version
          version: ${{ matrix.qt-version }}   # Qt version to install
          modules: ${{env.QT_MODULES}}
          cache: true
      - if: contains( matrix.os, 'macos') && startsWith( matrix.qt-version, '6.' )
        name: Install Qt 6 on macOS
        uses: jurplel/install-qt-action@v4
        with:
          aqtversion: '==3.1.*'               # Use the default aqtinstall version
          version: ${{ matrix.qt-version }}
          modules: ${{env.QT_MODULES}}
          cache: true


      #
      # Build SocNetV
      #
      # Test building with qmake and Qt 6.5
      - if: matrix.os == 'ubuntu-20.04' && matrix.qt-version == '6.5.3'
        name: Build ${{ env.VERSION }} for ${{matrix.os}} with Qt${{matrix.qt-version}} using qmake
        run: |
          echo "üîé Check openssl version:"
          echo `openssl version`
          echo "üîé Check output of 'which qmake6':"
          which qmake6
          echo "üîé Check qmake6 version:"
          qmake6 -v
          echo "üîß Running qmake on ubuntu 22.04 with ${{env.QMAKE_CONFIG}}..."
          qmake6 CONFIG+=${{env.QMAKE_CONFIG}}
          echo "üöß üõ†Ô∏è Compiling for linux with make -j${{env.CORES}}. Please wait..."
          make -j${{env.CORES}}
          echo "üëâ Building finished. Listing current directory with find for verification:"
          find .
      # Test building with cmake and all other versions of Qt
      - if: matrix.os == 'ubuntu-20.04' && matrix.qt-version != '6.5.3'
        name: Build ${{ env.VERSION }} for ${{matrix.os}} with Qt${{matrix.qt-version}} using cmake
        run: |

          echo "üîé Check openssl version:"
          echo `openssl version`

          echo "üí° Checking current directory..."
          pwd

          echo "üí° List current directory..."
          ls

          echo "üí° Deleting old build subdirectory..."
          rm -rf build

          echo "üîß Configuring project using 'cmake -S . -B build -DCMAKE_BUILD_TYPE=${{env.CMAKE_CONFIG}} -DCMAKE_INSTALL_PREFIX=${{env.APPDIR_PREFIX}}' ..."
          cmake -S . -B build -DCMAKE_BUILD_TYPE=${{env.CMAKE_CONFIG}} -DCMAKE_INSTALL_PREFIX=${{env.APPDIR_PREFIX}}

          echo "üîé Verifying ./build directory (before compiling)..."
          if [[ -d "./build" ]]; then
              echo "üéâ ./build directory created! Contents:"
              ls -lh ./build/
          else
              echo "‚ùå Error! ./build directory was not created!"
              exit 1
          fi

          echo "üöß Compiling the project..."
          cmake --build build -j$(nproc)

          echo "üîé Entering build directory..."
          cd build
          ls -lh .

          echo "üîé Search for built executable ./${{env.UNIXNAME}}*..."
          if [[ -f "./${{env.UNIXNAME}}" ]]; then
            echo "üéâ executable found!"
            ls -ls "${{env.UNIXNAME}}"
          else
              echo "‚ùå Error! ./build directory was not created!"
              exit 1
          fi
      # We build appImage on Ubuntu 20.04 and Qt 6.8 (latest LTS)
      - if: contains( matrix.os, 'ubuntu-20.04') && matrix.qt-version == '6.8.0'
        name: Create AppImage ${{ env.VERSION }} for ${{matrix.os}} with Qt${{matrix.qt-version}}
        run: |

          echo "üí° Checking current directory..."
          pwd

          echo "üîé Check where we are..."
          if [[ -d "./build" ]]; then
              echo "We are outside of ./build directory! Entering..."
              cd ./build/
          fi

          echo "üí° List current directory (./build)..."
          ls

          echo "üîß Installing the application into a new 'AppDir' directory..."
          make install DESTDIR=AppDir

          if [[ -d "./AppDir" ]]; then
              echo "üéâ SocNetv Installed in AppDir successfully!"
          else
              echo "‚ùå Error: AppDir was not created!"
              exit 1
          fi

          echo "üîß Installing linuxdeployqt..."
          wget https://github.com/probonopd/linuxdeployqt/releases/download/continuous/linuxdeployqt-continuous-x86_64.AppImage
          chmod a+x linuxdeployqt-continuous-x86_64.AppImage

          # NOTE: linuxdeployqt supports up to Ubuntu Focal Fossa
          echo "üöÄ Creating the AppImage using linuxdeployqt..."
          ./linuxdeployqt-continuous-x86_64.AppImage AppDir/${{env.APPDIR_PREFIX}}/share/applications/*.desktop \
            -appimage -extra-plugins=iconengines,imageformats

          ARTIFACT_FN="${{env.APP_NAME}}-${{env.VERSION}}-$(uname -i).AppImage"

          if [[ -f ${ARTIFACT_FN} ]]; then
              echo "üéâ AppImage created! Listing files in current directory..."
              ls -lh ./*.AppImage
              echo "...Exporting LINUX_ARTIFACT=${ARTIFACT_FN}"
              echo "LINUX_ARTIFACT=${ARTIFACT_FN}" >> $GITHUB_ENV
          else
              echo "‚ùå AppImage creation failed!"
              exit 1
          fi

      - if: contains( matrix.os, 'ubuntu-20.04') && matrix.qt-version == '6.8.0' && env.LINUX_ARTIFACT != ''
        name: üì§ Upload ${{matrix.os}} build artifacts of ${{env.APP_NAME}} ${{ env.VERSION }} to GitHub ${{ env.UPLOAD_URL }}
        run: |
          echo "üîç Verifying artifact: ${{ env.LINUX_ARTIFACT }}"
          pwd
          ls build
          if [ ! -f "./build/${{ env.LINUX_ARTIFACT }}" ]; then
            echo "‚ùå Error: Artifact not found!"
            exit 1
          fi

          echo "üì§ Uploading artifact to GitHub release..."
          gh release upload continuous "./build/${{ env.LINUX_ARTIFACT }}" --repo "${{ github.repository }}" \
            --clobber
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # - if: contains( matrix.os, 'ubuntu-20.04') && matrix.qt-version == '6.8.0' && env.LINUX_ARTIFACT != ''
      #   name: Upload ${{matrix.os}} build artifacts of ${{env.APP_NAME}} ${{ env.VERSION }} to GitHub ${{ env.UPLOAD_URL }}
      #   uses: actions/upload-release-asset@v1
      #   with:
      #     upload_url: ${{ env.UPLOAD_URL }}
      #     asset_path: ./${{ env.LINUX_ARTIFACT }}
      #     asset_name: "${{ env.LINUX_ARTIFACT }}"
      #     asset_content_type: "application/octet-stream"
      #   env:
      #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - if: contains( matrix.os, 'ubuntu-latest')
        name: Build ${{ env.VERSION }} for ${{matrix.os}} with Qt ${{matrix.qt-version}} using cmake
        run: |
          echo "üîé Check openssl version:"
          echo `openssl version`

          echo "üí° Checking current directory..."
          pwd

          echo "üí° List current directory..."
          ls

          echo "üí° Deleting old build subdirectory..."
          rm -rf build

          echo "üîß Configuring project using 'cmake -S . -B build -DCMAKE_BUILD_TYPE=${{env.CMAKE_CONFIG}} -DCMAKE_INSTALL_PREFIX=${{env.APPDIR_PREFIX}}' ..."
          cmake -S . -B build -DCMAKE_BUILD_TYPE=${{env.CMAKE_CONFIG}} -DCMAKE_INSTALL_PREFIX=${{env.APPDIR_PREFIX}}

          echo "üîé Verifying ./build directory (before compiling)..."
          if [[ -d "./build" ]]; then
              echo "üéâ ./build directory created! Contents:"
              ls -lh ./build/
          else
              echo "‚ùå Error! ./build directory was not created!"
              exit 1
          fi

          echo "üöß Compiling the project..."
          cmake --build build -j$(nproc)

          echo "üîé Entering build directory..."
          cd build
          ls -lh .

          echo "üîé Search for built executable ./${{env.UNIXNAME}}*..."
          if [[ -f "./${{env.UNIXNAME}}" ]]; then
            echo "üéâ executable found!"
            ls -ls "${{env.UNIXNAME}}"
          else
              echo "‚ùå Error! ./build directory was not created!"
              exit 1
          fi


      # BUILD FOR MACOS
      - if: contains( matrix.os, 'macos') && matrix.qt-version == '6.5.3'
        name: Build ${{env.APP_NAME}} ${{ env.VERSION }} for ${{matrix.os}} with Qt ${{matrix.qt-version}} using qmake
        run: |
          echo "üçé Preparing macOS build..."
          echo "Building version: ${{env.VERSION}}"
          # Ensure Qt is installed and in PATH
          # export PATH="$(brew --prefix qt)/bin:$PATH"
          which qmake

          echo "üîß Running 'qmake CONFIG+=${{env.QMAKE_CONFIG}} ${{env.QMAKE_PROJECT}}' to configure on macos..."
          qmake CONFIG+=${{env.QMAKE_CONFIG}} ${{env.QMAKE_PROJECT}}
          echo "üöß üõ†Ô∏è Compiling for macos with make. Please wait..."
          make

          echo "üëâ Building finished! Searching for built ${{matrix.os}} bundle (DIRECTORY!)./${{env.APP_NAME}}.app ..."
          if [[ -d "./${{env.APP_NAME}}.app" ]]; then
            echo "üéâ ${{matrix.os}} bundle created! Bundle contents:"
            find "${{env.APP_NAME}}.app"
          else
            echo "‚ùå Error! ${{matrix.os}} bundle not found !"
            exit 1
          fi


          # Verify the binary with lipo
          echo "üîé Verifying architectures in the built binary..."
          if [[ -f "${{env.APP_NAME}}.app/Contents/MacOS/${{env.APP_NAME}}" ]]; then
              lipo -info "${{env.APP_NAME}}.app/Contents/MacOS/${{env.APP_NAME}}"
          else
              echo "‚ùå Error: Binary file not found!"
              exit 1
          fi

          echo "üîß Removing items we do not deploy from project dir ..."
          rm -rf moc obj qrc

          # Run macdeployqt to bundle the app
          echo "üöÄ Running macdeployqt to create macOS bundle..."
          macdeployqt "${{env.APP_NAME}}.app" -dmg -verbose=3 || {
            echo "Error: macdeployqt failed."
            exit 1
          }

          # Verify the bundled libraries in the binary
          echo "üîé Verify the bundled libraries in the built binary ..."
          if [[ -f "${{env.APP_NAME}}.app/Contents/MacOS/${{env.APP_NAME}}" ]]; then
              otool -L "${{env.APP_NAME}}.app/Contents/MacOS/${{env.APP_NAME}}"
          else
              echo "‚ùå Error: Binary file not found!"
              exit 1
          fi

          # Rename DMG file
          if [[ -f ${{env.APP_NAME}}.dmg ]]; then
            DMG_NAME="${{env.APP_NAME}}-${{env.VERSION}}.dmg"
            mv "${{env.APP_NAME}}.dmg" "${DMG_NAME}"
            echo "üéâ Build and packaging complete. Final DMG: ${DMG_NAME}"
            ls -lh *.dmg
            echo "Artifact created! Exporting MAC_ARTIFACT=${DMG_NAME}"
            echo "MAC_ARTIFACT=${DMG_NAME}" >> $GITHUB_ENV
          else
            echo "Error: DMG creation failed. No DMG file found. Skipping upload."
            exit 1
          fi
      - if: contains( matrix.os, 'macos') && matrix.qt-version != '6.5.3'
        name: Build ${{env.APP_NAME}} ${{ env.VERSION }} for ${{matrix.os}} with Qt ${{matrix.qt-version}} using cmake
        run: |
          echo "üçé Preparing macOS build..."

          echo "üîé Check openssl version:"
          echo `openssl version`

          echo "üí° Checking current directory..."
          pwd

          echo "üí° List current directory..."
          ls

          echo "üí° Deleting old build subdirectory..."
          rm -rf build

          echo "üîß Configuring project using 'cmake -S . -B build -DCMAKE_BUILD_TYPE=${{env.CMAKE_CONFIG}} -DCMAKE_INSTALL_PREFIX=${{env.APPDIR_PREFIX}}' ..."
          cmake -S . -B build -DCMAKE_BUILD_TYPE=${{env.CMAKE_CONFIG}} -DCMAKE_INSTALL_PREFIX=${{env.APPDIR_PREFIX}}

          echo "üîé Verifying ./build directory (before compiling)..."
          if [[ -d "./build" ]]; then
              echo "üéâ ./build directory created! Contents:"
              ls -lh ./build/
          else
              echo "‚ùå Error! ./build directory was not created!"
              exit 1
          fi

          echo "üöß Compiling the project..."
          cmake --build build -j$(sysctl -n hw.ncpu)

          echo "üîé Entering build directory..."
          cd build
          ls -lh .

          echo "üîé Search for built ${{matrix.os}} bundle (DIRECTORY!)./${{env.APP_NAME}}.app ..."
          if [[ -d "./${{env.APP_NAME}}.app" ]]; then
            echo "üéâ ${{matrix.os}} bundle created! Bundle contents:"
            find "${{env.APP_NAME}}.app"
          else
            echo "‚ùå Error! ${{matrix.os}} bundle not found !"
            exit 1
          fi

          # Verify the binary with lipo
          echo "üîé Verifying architectures in the ${{matrix.os}} bundle..."
          if [[ -f "${{env.APP_NAME}}.app/Contents/MacOS/${{env.APP_NAME}}" ]]; then
              lipo -info "${{env.APP_NAME}}.app/Contents/MacOS/${{env.APP_NAME}}"
          else
              echo "‚ùå Error: ${{env.APP_NAME}}.app/Contents/MacOS/${{env.APP_NAME}} file not found!"
              exit 1
          fi

          # Verify PkgInfo is present
          echo "üîé Checking for PkgInfo in the app bundle..."
          if [[ -f "${{env.APP_NAME}}.app/Contents/PkgInfo" ]]; then
              echo "‚úÖ PkgInfo exists."
          else
              echo "‚ùå PkgInfo is missing! Creating it now..."
              echo "APPL????" > "${{env.APP_NAME}}.app/Contents/PkgInfo"
              ls -l "${{env.APP_NAME}}.app/Contents/PkgInfo"  # Verify it's created
              echo "‚úÖ PkgInfo has been successfully created."
          fi

          # Check for any other unexpected files in the root
          echo "üîé Checking for other unexpected files in the root..."
          ROOT_FILES=$(find "${{env.APP_NAME}}.app" -maxdepth 1 -type f)
          if [[ -n "$ROOT_FILES" ]]; then
              echo "‚ö†Ô∏è Found unexpected files in app bundle root:"
              echo "$ROOT_FILES"
              echo "Removing these files..."
              find "${{env.APP_NAME}}.app" -maxdepth 1 -type f -delete
          fi

          # List all extended attributes and clear them if necessary
          find "${{env.APP_NAME}}.app" -type f -exec xattr -l {} \; | grep -v "^$" && \
          find "${{env.APP_NAME}}.app" -type f -exec xattr -c {} \;

          echo "üîë Import macOS Developer Certificate"
          echo "${{ secrets.MACOS_CERTIFICATE }}" | base64 --decode > certificate.p12
          security create-keychain -p "" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "" build.keychain
          security import certificate.p12 -k build.keychain -P "${{ secrets.MACOS_CERTIFICATE_PASSWORD }}" -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple: -k "" build.keychain
          rm -f certificate.p12

          echo "üõ†Ô∏è Store Apple ID Credentials for Notarization"
          xcrun notarytool store-credentials "AC_PASSWORD" \
          --apple-id "${{ secrets.AC_APPLE_ID }}" \
          --team-id "${{ secrets.AC_TEAM_ID }}" \
          --password "${{ secrets.AC_PASSWORD }}"

          echo "üîè Sign SocNetV.app"
          codesign --deep --force --verbose \
          --options runtime \
          --entitlements ../scripts/entitlements.plist \
          --sign "Developer ID Application: Dimitris Kalamaras (K89VSL4N97)" \
          "${{env.APP_NAME}}.app"

          # Run macdeployqt to bundle the app
          echo "üöÄ Running macdeployqt to create macOS bundle..."
          macdeployqt "${{env.APP_NAME}}.app" -dmg -verbose=3 || {
            echo "Error: macdeployqt failed."
            exit 1
          }

          # Verify the bundled libraries in the binary
          echo "üîé Verify the bundled libraries in the built binary ..."
          if [[ -f "${{env.APP_NAME}}.app/Contents/MacOS/${{env.APP_NAME}}" ]]; then
              otool -L "${{env.APP_NAME}}.app/Contents/MacOS/${{env.APP_NAME}}"
          else
              echo "‚ùå Error: Binary file not found!"
              exit 1
          fi


          echo "üìú Notarize the DMG"
          xcrun notarytool submit ${{env.APP_NAME}}.dmg \
          --keychain-profile "AC_PASSWORD" --wait

          # Rename DMG file **AFTER** notarization
          if [[ -f ${{env.APP_NAME}}.dmg ]]; then
            DMG_NAME="${{env.APP_NAME}}-${{env.VERSION}}.dmg"
            mv "${{env.APP_NAME}}.dmg" "${DMG_NAME}"
            echo "üéâ Build and packaging complete. Final DMG: ${DMG_NAME}"
            ls -lh *.dmg
            echo "Artifact created! Exporting MAC_ARTIFACT=${DMG_NAME}"
            echo "MAC_ARTIFACT=${DMG_NAME}" >> $GITHUB_ENV
          else
             echo "Error: DMG creation failed. No DMG file found. Skipping upload."
             exit 1
          fi

          # Staple notarization **AFTER RENAMING** the DMG
          echo "üìå Staple Notarization"
          xcrun stapler staple "${DMG_NAME}"

      - if: contains( matrix.os, 'macos') && matrix.qt-version == '6.8.0' && env.MAC_ARTIFACT != ''
        name: üì§ Upload ${{matrix.os}} build artifacts of ${{env.APP_NAME}} ${{ env.VERSION }} to GitHub ${{ env.UPLOAD_URL }}
        run: |
          echo "üîç Verifying artifact: ${{ env.MAC_ARTIFACT }}"
          pwd
          ls build
          if [ ! -f "./build/${{ env.MAC_ARTIFACT }}" ]; then
            echo "‚ùå Error: Artifact not found!"
            exit 1
          fi

          echo "üì§ Uploading artifact to GitHub release..."
          gh release upload continuous "./build/${{ env.MAC_ARTIFACT }}" --repo "${{ github.repository }}" \
            --clobber
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Upload artifacts from macOS build to 'continuous' pre-release tag
      # - if: contains( matrix.os, 'macos') && matrix.qt-version == '6.8.0' && env.MAC_ARTIFACT != ''
      #   name: Upload ${{matrix.os}} build artifacts of ${{env.APP_NAME}} ${{ env.VERSION }} to GitHub ${{ env.UPLOAD_URL }}
      #   uses: actions/upload-release-asset@v1
      #   with:
      #     upload_url: ${{ env.UPLOAD_URL }}
      #     asset_path: ./${{ env.MAC_ARTIFACT }}
      #     asset_name: "${{ env.MAC_ARTIFACT }}"
      #     asset_content_type: "application/octet-stream"
      #   env:
      #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # BUILD FOR WINDOWS
      - if: contains( matrix.os, 'windows') && matrix.qt-version == '6.5.3'
        name: Build ${{env.APP_NAME}} ${{ env.VERSION }} for ${{matrix.os}} with Qt ${{matrix.qt-version}} using qmake.
        run: |
          echo "üîé Listing some directories"
          dir D:\a\app\Qt\
          echo "üîß Running 'qmake6 CONFIG+=${{env.QMAKE_CONFIG}} ${{env.QMAKE_PROJECT}} -r' to configure the project on Windows..."
          qmake6 CONFIG+=${{env.QMAKE_CONFIG}} TARGET.path=${{env.QMAKE_CONFIG}} ${{env.QMAKE_PROJECT}} -r
          echo "üöß üõ†Ô∏è Compiling with nmake. Please wait..."
          nmake
          echo "üëâ Building finished. Listing  directory ${{env.QMAKE_CONFIG}} for verification:"
          dir ${{env.QMAKE_CONFIG}}

      - if: contains( matrix.os, 'windows') && matrix.qt-version != '6.5.3'
        name: Build ${{env.APP_NAME}} ${{ env.VERSION }} for ${{matrix.os}} with Qt ${{matrix.qt-version}} using cmake.
        run: |
          echo "üîé Listing some directories"
          dir D:\a\app\Qt\

          echo "üîé Verifying Qt installation path..."
          where qmake
          where windeployqt

          echo "üí° Creating build dir"
          mkdir build
          echo "üîß Running 'cmake -S . -B build' to configure the project..."
          cmake -S . -B build
          echo "üöß üõ†Ô∏è Compiling into build/ with 'cmake --build build -j${{env.CORES}} --config ${{env.CMAKE_CONFIG}}'. Please wait..."
          cmake --build build -j${{env.CORES}} --config ${{env.CMAKE_CONFIG}} -v
          echo "üëâ Building finished. Entering build/ and listing it for verification: "
          cd build
          dir

          echo "üîß Running windeployqt on built executable (and ensuring required .dlls are copied into the folder)..."
          windeployqt ${{env.CMAKE_CONFIG}}\socnetv.exe --release --compiler-runtime

          echo "üîß Manually copying MSVC runtime DLLs..."
          if (!(Test-Path "C:\Windows\System32\MSVCP140_1.dll")) {
              echo "‚ùå MSVCP140_1.dll NOT FOUND in System32! This may cause runtime errors."
              exit 1  # Fail the build when the file is missing
          }
          if (!(Test-Path "C:\Windows\System32\MSVCP140_2.dll")) {
              echo "‚ùå MSVCP140_2.dll NOT FOUND in System32! This may cause runtime errors."
              exit 1  # Fail the build when the file is missing
          }
          copy "C:\Windows\System32\MSVCP140.dll" ${{env.CMAKE_CONFIG}}\
          copy "C:\Windows\System32\MSVCP140_1.dll" ${{env.CMAKE_CONFIG}}\
          copy "C:\Windows\System32\MSVCP140_2.dll" ${{env.CMAKE_CONFIG}}\
          copy "C:\Windows\System32\VCRUNTIME140.dll" ${{env.CMAKE_CONFIG}}\
          copy "C:\Windows\System32\VCRUNTIME140_1.dll" ${{env.CMAKE_CONFIG}}\
          copy "C:\Windows\System32\CONCRT140.dll" ${{env.CMAKE_CONFIG}}\

          echo "üîß Copying license file to build directory..."
          copy ..\COPYING ${{env.CMAKE_CONFIG}}\LICENSE.txt

          echo "üëâ Checking deployed DLLs..."
          dir ${{env.CMAKE_CONFIG}}

          if (!(Get-Command "iscc.exe" -ErrorAction SilentlyContinue)) {
            echo "üîß Installing Inno Setup..."
            choco install -y InnoSetup
          } else {
            echo "Inno Setup is already installed. Skipping installation."
          }

          echo "üîß Adding Inno Setup to PATH..."
          $env:PATH += ";C:\Program Files (x86)\Inno Setup 6\"

          echo "üîß Verifying Inno Setup Installation..."
          iscc.exe /?

          echo "üîß Copying InnoSetup script..."
          copy ..\scripts\innosetup.iss innosetup.iss

          echo "Updating RELEASEFOLDER in innosetup.iss with ${{env.CMAKE_CONFIG}}..."
          $config = "${{env.CMAKE_CONFIG}}"
          $replacement = "#define RELEASEFOLDER `"$config\\`""
          (Get-Content innosetup.iss) -replace '#define RELEASEFOLDER "release\\"', $replacement | Set-Content innosetup.iss
          echo "Updated innosetup.iss:"
          type innosetup.iss

          echo "üîß Running Inno Setup to create installer..."
          & "C:\Program Files (x86)\Inno Setup 6\ISCC.exe" "innosetup.iss"

          echo "üëâ Checking if installer exists in current directory ..."
          dir
          $originalInstaller = Get-ChildItem -Path "SocNetV-*installer.exe" -ErrorAction SilentlyContinue
          if (-not $originalInstaller) {
            echo "‚ùå Error: Installer file not found!"
            exit 1
          }

          echo "üîß Renaming installer..."
          $installerName = "SocNetV-${{env.VERSION}}-windows-installer.exe"
          Get-ChildItem -Path "SocNetV-*installer.exe" | Move-Item -Destination $installerName
          dir

          echo "üéâ Exporting installer name to environment variable..."
          echo "WINDOWS_ARTIFACT=$installerName" >> $env:GITHUB_ENV

          echo "üéâ Windows build complete. Artifacts are ready!"

      - if: contains( matrix.os, 'windows') && matrix.qt-version == '6.8.0' && env.WINDOWS_ARTIFACT != ''
        name: üì§ Upload ${{matrix.os}} build artifacts of ${{env.APP_NAME}} ${{ env.VERSION }} to GitHub ${{ env.UPLOAD_URL }}
        run: |
          echo "üîç Verifying artifact: ${{ env.WINDOWS_ARTIFACT }}"
          echo "Current working directory:"
          pwd

          echo "Contents of build directory:"
          Get-ChildItem -Path build

          if (!(Test-Path -Path "./build/${{ env.WINDOWS_ARTIFACT }}")) {
            echo "‚ùå Error: Artifact not found!"
            exit 1
          }

          echo "üì§ Uploading artifact to GitHub release..."
          gh release upload continuous "./build/${{ env.WINDOWS_ARTIFACT }}" `
            --repo "${{ github.repository }}" `
            --clobber
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - run: echo "üçè This job's status is ${{ job.status }}."
